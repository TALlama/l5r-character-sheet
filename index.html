<!doctype html>
<html class="no-js" lang="">

  <head>
    <meta charset="utf-8">
    <title></title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="manifest" href="site.webmanifest">
    <link rel="apple-touch-icon" href="icon.png">
    <!-- Place favicon.ico in the root directory -->

    <link rel="stylesheet" href="css/normalize.css">
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/l5r.css">

    <meta name="theme-color" content="#fafafa">
  </head>

  <body>
    <article class='rollbox'>
      <header class='rollbox--header'>
        <label>Ring dice <input class='rollbox--ring' type='number' value='3'/></label>
        <label>Skill dice <input class='rollbox--skill' type='number' value='2'/></label>
        <button class='rollbox--trigger' >Roll!</button>
      </header>
      
      <article class='dice-tray rollbox--current-dice-tray'></article>
      <a href='#' class='rollbox--roll-exploding hidden' data-shown-if='exploding'>roll <span data-shows='exploding'>0</span> exploding</a>
      
      <dl class='rollbox--outcome'>
        <dt>keeps-left</dt>
        <dd><output class='rollbox--output' data-shows='keepsLeft'>3</output></dd>
        
        <dt class='hidden' data-shown-if='successes'>successes</dt>
        <dd class='hidden' data-shown-if='successes'><output class='rollbox--output' data-shows='successes'></output></dd>
        
        <dt class='hidden' data-shown-if='opportunities'>opportunities</dt>
        <dd class='hidden' data-shown-if='opportunities'><output class='rollbox--output' data-shows='opportunities'></output></dd>
        
        <dt class='hidden' data-shown-if='strife'>strife</dt>
        <dd class='hidden' data-shown-if='strife'><output class='rollbox--output' data-shows='strife'></output></dd>
        
        <dt class='hidden' data-shown-if='rerolls'>rerolls</dt>
        <dd class='hidden' data-shown-if='rerolls'><output class='rollbox--output' data-shows='rerolls'></output></dd>
      </dl>
      <!-- roll(document.querySelector("#ring").value, document.querySelector("#ring").value) -->
    </article>
    
    <script>
      class Rollable {
        get successes() { return this.maxCountOf('S'); }
        get exploding() { return this.maxCountOf('R'); }
        get opportunities() { return this.maxCountOf('O'); }
        get strife() { return this.maxCountOf('X'); }
        

        get rolledSuccesses() { return this.rolledCountOf('S'); }
        get rolledExploding() { return this.rolledCountOf('R'); }
        get rolledOpportunities() { return this.rolledCountOf('O'); }
        get rolledStrife() { return this.rolledCountOf('X'); }
        
        rolledCountOf(symbol) {
          return this.symbols.reduce((count, sym) => sym === symbol ? count + 1 : count, 0);
        }
        
        maxCountOf(symbol, keeping=this.ringCount || 0) {
          return Math.min(keeping, this.rolledCountOf(symbol));
        }
        
        toString() {
          return this.symbols.join(", ");
        }
      }
      
      class Die extends Rollable {
        get face() {
          this._face || this.roll();
          return this._face;
        }
        
        get symbols() {
          return this.face.split('');
        }
        
        get imageTag() {
          let img = document.createElement('img')
          img.setAttribute('src', `img/dice/${this.dieType}-${this.face}.png`);
          img.setAttribute('width', `70px`);
          return img;
        }
        
        roll() {
          let faces = this.possibleFaces;
          this._face = faces[Math.floor(Math.random() * faces.length)];
        }
        
        toString() {
          return this.face;
        }
      }
      
      class RingDie extends Die {
        get possibleFaces() {return ['-', 'OX', 'O', 'SX', 'S', 'RX'];}
        get dieType() { return 'ring'; }
        toString() { return `[${super.toString()}]`; }
      }
      
      class SkillDie extends Die {
        get possibleFaces() {return ['-', '-', 'O', 'O', 'O', 'SX', 'SX', 'S', 'S', 'SO', 'RX', 'R'];}
        get dieType() { return 'skill'; }
        toString() { return `{${super.toString()}}`; }
      }
      
      class DicePool extends Rollable {
        constructor(ring, skill) {
          super();
          
          this.ringCount = Number(ring);
          this.skillCount = Number(skill);
        
          this.dice = [];
          for (let r = 0; r < this.ringCount; r++) {
            this.dice.push(new RingDie());
          }
          for (let s = 0; s < this.skillCount; s++) {
            this.dice.push(new SkillDie());
          }
        }
        
        get faces() {
          return this.dice.map(d => d.face).sort();
        }
        
        get symbols() {
          return this.dice.flatMap(d => d.symbols).sort();
        }
        
        roll() {
          this.dice.forEach(d => d.roll());
        }
        
        static forDice(dice) {
          let ringCount = dice.reduce((count, d) => d.constructor == RingDie ? count + 1 : count, 0);
          let skillCount = dice.reduce((count, d) => d.constructor == SkillDie ? count + 1 : count, 0);
          return new DicePool(ringCount, skillCount);
        }
      }
      
      function roll(ring, skill) {
        let pool = new DicePool(ring, skill);
        alert(pool.symbols.join("|"));
      }
      
      class Rollbox {
        constructor(root) {
          this.root = root;
        }
        
        get ringCount() { return this.root.querySelector('.rollbox--ring').value; }
        get skillCount() { return this.root.querySelector('.rollbox--skill').value; }
        
        get currentDiceTray() { return this.root.querySelector('.rollbox--current-dice-tray'); }
        get kept() { return this.root.querySelectorAll('.rollbox--keeper---kept'); }
        get keptInFirst() { return this.root.querySelectorAll('.dice-tray:first-of-type .rollbox--keeper---kept'); }
        get keptInCurrent() { return this.root.querySelectorAll('.rollbox--current-dice-tray .rollbox--keeper---kept'); }
        
        get keepsLeft() { return this.ringCount - this.keptInFirst.length; }
        get successes() { return this.keptCount(k => k.die.rolledSuccesses + k.die.rolledExploding); }
        get exploding() { return this.keptCount(k => k.die.rolledExploding, true); }
        get opportunities() { return this.keptCount(k => k.die.rolledOpportunities); }
        get strife() { return this.keptCount(k => k.die.rolledStrife); }
        
        get explodingDice() { return Array.prototype.filter.call(this.keptInCurrent, kept => kept.die.rolledExploding > 0).map(kept => new kept.die.constructor); }
        
        roll() {
          this.rerolls = 0;
          
          this.dicePool = new DicePool(this.ringCount, this.skillCount);
          this.dicePool.roll();

          this.resetTrays();
          this.showDice();
          this.updateOutcome();
        }
        
        rollExploding() {
          let pool = DicePool.forDice(this.explodingDice);
          new DiceTray(this.addDiceTray(), pool).addDice(this);
          this.updateOutcome();
        }
        
        addDiceTray() {
          let trays = this.root.querySelectorAll('.dice-tray');
          let last = trays[trays.length - 1];
          
          let tray = document.createElement('article');
          tray.classList.add('dice-tray');
          last.after(tray);
          
          this.setCurrentDiceTray(tray);
          
          return tray;
        }
        
        setCurrentDiceTray(tray) {
          this.root.querySelectorAll('.dice-tray').forEach(t => {
            t.classList.toggle('rollbox--current-dice-tray', t == tray);
          });
        }
        
        keptCount(fn, onlyCurrent=false) {
          let kept = onlyCurrent ? this.keptInCurrent : this.kept;
          return Array.prototype.map.call(kept, fn).reduce((c, i) => c + i, 0);
        }
        
        resetTrays() {
          this.root.querySelectorAll('.dice-tray:not(.rollbox--current-dice-tray)').forEach(t => t.remove());
        }
        
        showDice() {
          let tray = new DiceTray(this.currentDiceTray, this.dicePool);
          tray.empty();
          tray.addDice(this);
        }
        
        keepChanged(event) {
          let keeper = event.target.closest('.rollbox--keeper');
          keeper.classList.toggle('rollbox--keeper---kept', event.target.checked);
          this.updateOutcome();
        }
        
        updateOutcome() {
          this.root.querySelectorAll('*[data-shows]').forEach(el => {
            el.innerText = this[el.dataset.shows];
          });
          this.root.querySelectorAll('*[data-shown-if]').forEach(el => {
            el.classList.toggle('hidden', !this[el.dataset.shownIf]);
          });
        }
        
        static rooted(el) {
          return el.rollbox = el.rollbox || new Rollbox(el);
        }
      }
      
      class DiceTray {
        constructor(root, dicePool) {
          this.root = root;
          this.dicePool = dicePool;
        }
        
        empty() {
          this.root.innerText = '';
        }
        
        addDice(rollbox) {
          this.dicePool.dice.forEach(die => {
            let keepUi = document.createElement('article');
            keepUi.classList.add('rollbox--keeper');
            keepUi.die = die;
            
            let keepCheckUi = document.createElement('input');
            keepCheckUi.classList.add('sr-only');
            keepCheckUi.setAttribute('type', 'checkbox');
            keepCheckUi.addEventListener('change', e => rollbox.keepChanged(e));
            
            let dieUi = document.createElement('label');
            dieUi.classList.add('die');
            dieUi.append(keepCheckUi);
            dieUi.append(die.imageTag);
            keepUi.append(dieUi);
            
            let actions = document.createElement('article');
            actions.classList.add('rollbox--keeper-actions');
            keepUi.append(actions);
            
            let rerollLink = document.createElement('a');
            rerollLink.setAttribute('href', '#');
            rerollLink.append('reroll');
            rerollLink.addEventListener('click', e => {
              e.preventDefault();
              
              die.roll();
              
              rollbox.rerolls += 1;
              rollbox.updateOutcome();
              
              dieUi.innerText = '';
              dieUi.append(keepCheckUi);
              dieUi.append(die.imageTag);
            });
            actions.append(rerollLink);
            
            this.root.append(keepUi);
          });
        }
      }
      
      document.addEventListener('click', e => {
        if (e.target.matches('.rollbox--trigger')) {
          Rollbox.rooted(e.target.closest('.rollbox')).roll(event);
        } else if (e.target.matches('.rollbox--roll-exploding')) {
          Rollbox.rooted(e.target.closest('.rollbox')).rollExploding(event);
        }
      })
      
      document.querySelector('.rollbox--trigger').click();
    </script>
    <style>
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        margin: -1px;
        padding: 0;
        overflow: hidden;
        clip: rect(0 0 0 0);
        border: 0;
      }
      
      .rollbox {
        border: 1px solid #ccc;
        border-radius: 3px;
        box-shadow: 3px 3px 3px #ddd;
        padding: 10px;
        margin: 10px;
      }
      
        .rollbox--header {
          font-size: 150%;
          padding-bottom: 5px;
          margin-bottom: 10px;
          border-bottom: 1px solid #ccc;
        }
        
          .rollbox--header input {
            width: 5ch;
          }
      
        .rollbox--roll-exploding {
          font-size: 150%;
          border: 1px solid #ccc;
          padding: 5px 25px;
          border-radius: 3;
          display: inline-block;
          animation: rumble 1s infinite;
        }
        
        @keyframes rumble {
            0% { transform: translate( 0px) rotate( 0deg); }
           10% { transform: translate( 2px) rotate( 1deg); }
           20% { transform: translate(-2px) rotate(-1deg); }
           30% { transform: translate(-3px) rotate( 1deg); }
           40% { transform: translate( 4px) rotate(-1deg); }
           50% { transform: translate( 0px) rotate( 2deg); }
           60% { transform: translate(-1px) rotate( 1deg); }
           70% { transform: translate(-4px) rotate( 2deg); }
           80% { transform: translate( 2px) rotate( 1deg); }
           90% { transform: translate( 1px) rotate(-1deg); }
          100% { transform: translate(-2px) rotate(-1deg); }
        }
        
        .rollbox--outcome {
          margin-top: 10px;
          display: grid;
          grid-template-columns: 1fr 10fr;
        }
        
        .rollbox--outcome dt {
          text-align: end;
          padding-right: 1em;
        }
        
        .dice-tray {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
          grid-gap: 5px;
          padding: 5px 0;
        }
        
        .rollbox--keeper {
          border: 1px solid #ccc;
          border-radius: 3px;
          display: flex;
        }
          .rollbox--keeper label:focus-within {
            outline: 2px solid blue;
            outline-color: -webkit-focus-ring-color;
          }
        
          .rollbox--keeper---kept {
            background-color: #ccc;
          }
          
          .rollbox--keeper label {
            padding: 5px;
            font-size: 200%;
            flex-grow: 1;
          }
          
          .rollbox--keeper-actions {
            border-left: 1px solid #ccc;
            display: flex;
            flex-direction: column;
            font-size: 80%;
          }
          
            .rollbox--keeper-actions a {
              padding: 5px;
            }
    </style>
</html>
